// Prisma Schema for Nairobi Sculpt Surgical Aesthetic Clinic
// PostgreSQL Database Schema with full relational integrity

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // REFACTORED: Appending `&connection_limit=10&pool_timeout=10` to handle
  // limited connection slots on Aiven (Postgres Superuser reserveration error).
  // Ideally, use a PgBouncer connection string if available.
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Recommended for migrations if using PgBouncer
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  ADMIN
  NURSE
  DOCTOR
  LAB_TECHNICIAN
  PATIENT
  CASHIER
  FRONTDESK
}

enum Status {
  ACTIVE
  INACTIVE
  DORMANT
}

enum JOBTYPE {
  FULL
  PART
}

enum Gender {
  MALE
  FEMALE
}

enum AppointmentStatus {
  PENDING
  PENDING_DOCTOR_CONFIRMATION
  CONFIRMED
  SCHEDULED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum ConsultationRequestStatus {
  SUBMITTED
  PENDING_REVIEW
  NEEDS_MORE_INFO
  APPROVED
  SCHEDULED
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  BANK_TRANSFER
}

enum PaymentStatus {
  PAID
  UNPAID
  PART
}

enum CareNoteType {
  PRE_OP
  POST_OP
  GENERAL
}

enum NotificationType {
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  READ
}

enum DoctorOnboardingStatus {
  INVITED
  ACTIVATED
  PROFILE_COMPLETED
  ACTIVE
}

enum ConsultUrgency {
  ROUTINE
  URGENT
  INTRA_OP
}

enum ConsultStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum ImageTimepoint {
  PRE_OP
  ONE_WEEK_POST_OP
  ONE_MONTH_POST_OP
  THREE_MONTHS_POST_OP
  SIX_MONTHS_POST_OP
  ONE_YEAR_POST_OP
  CUSTOM
}

enum ImageAngle {
  FRONT
  OBLIQUE_LEFT
  OBLIQUE_RIGHT
  PROFILE_LEFT
  PROFILE_RIGHT
  BACK
  TOP
  BOTTOM
  CUSTOM
}

enum CaseReadinessStatus {
  NOT_STARTED
  IN_PROGRESS
  PENDING_LABS
  PENDING_CONSENT
  PENDING_REVIEW
  READY
  ON_HOLD
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum OutcomeStatus {
  EXCELLENT
  GOOD
  SATISFACTORY
  NEEDS_REVISION
  COMPLICATION
}

enum SurgicalUrgency {
  ELECTIVE
  URGENT
  EMERGENCY
}

enum AnesthesiaType {
  GENERAL
  REGIONAL
  LOCAL
  SEDATION
  TIVA
  MAC
}

enum SurgicalRole {
  SURGEON
  ASSISTANT_SURGEON
  ANESTHESIOLOGIST
  ANESTHETIST_NURSE
  SCRUB_NURSE
  CIRCULATING_NURSE
  THEATER_TECHNICIAN
}

enum WoundClassification {
  CLEAN
  CLEAN_CONTAMINATED
  CONTAMINATED
  DIRTY_INFECTED
}

enum ConsentStatus {
  DRAFT
  PENDING_SIGNATURE
  SIGNED
  REVOKED
  EXPIRED
}

enum ConsentType {
  GENERAL_PROCEDURE
  ANESTHESIA
  BLOOD_TRANSFUSION
  PHOTOGRAPHY
  SPECIAL_PROCEDURE
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password_hash String
  role          Role
  status        Status    @default(ACTIVE)
  mfa_enabled   Boolean   @default(false)
  mfa_secret    String?
  first_name    String?
  last_name     String?
  phone         String?
  last_login_at DateTime?

  // Relations
  refresh_tokens         RefreshToken[]
  audit_logs             AuditLog[]
  notifications_sent     Notification[]    @relation("NotificationSender")
  notifications_received Notification[]    @relation("NotificationRecipient")
  patient_profile        Patient?          @relation("PatientUser")
  doctor_profile         Doctor?           @relation("DoctorUser") // Optional: User may not have Doctor profile, but Doctor MUST have User
  assigned_patients      Patient[]         @relation("PatientAssignment")
  nurse_assignments      NurseAssignment[] @relation("NurseAssignments")
  care_notes             CareNote[]        @relation("CareNoteNurse")
  surgical_assignments   SurgicalStaff[]
  witnessed_consents     ConsentForm[]
  consultations          Consultation[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([role])
  @@index([status])
  @@index([role, status])
}

model RefreshToken {
  id         Int       @id @default(autoincrement())
  user_id    String
  token      String    @unique
  expires_at DateTime
  revoked    Boolean   @default(false)
  revoked_at DateTime?

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([token])
  @@index([expires_at])
  @@index([user_id, revoked])
}

// ============================================================================
// PATIENT
// ============================================================================

model Patient {
  id                       String    @id @default(uuid())
  file_number              String    @unique // System-generated: NS001, NS002, NS003, etc.
  user_id                  String?   @unique // Link to User if patient has account
  first_name               String
  last_name                String
  date_of_birth            DateTime
  gender                   Gender    @default(FEMALE)
  phone                    String
  whatsapp_phone           String? // WhatsApp contact number (optional)
  email                    String    @unique
  marital_status           String
  occupation               String? // Patient's occupation (optional)
  address                  String
  emergency_contact_name   String
  emergency_contact_number String
  relation                 String
  blood_group              String?
  allergies                String?
  medical_conditions       String?
  medical_history          String?
  insurance_provider       String?
  insurance_number         String?
  privacy_consent          Boolean   @default(false)
  service_consent          Boolean   @default(false)
  medical_consent          Boolean   @default(false)
  img                      String?
  colorCode                String?
  approved                 Boolean   @default(false)
  approved_by              String?
  approved_at              DateTime?
  assigned_to_user_id      String? // Assigned staff member

  // Relations
  user                 User?                @relation("PatientUser", fields: [user_id], references: [id], onDelete: SetNull)
  assigned_to          User?                @relation("PatientAssignment", fields: [assigned_to_user_id], references: [id], onDelete: SetNull)
  appointments         Appointment[]
  medical_records      MedicalRecord[]
  payments             Payment[]
  ratings              Rating[]
  nurse_assignments    NurseAssignment[]
  care_notes           CareNote[]
  vital_signs          VitalSign[]
  diagnoses            Diagnosis[]          @relation("PatientDiagnosis")
  doctor_consultations DoctorConsultation[]
  case_plans           CasePlan[]
  patient_images       PatientImage[]
  clinical_tasks       ClinicalTask[]
  surgical_outcomes    SurgicalOutcome[]
  surgical_cases       SurgicalCase[]    // New Architecture

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([user_id])
  @@index([assigned_to_user_id])
  @@index([approved])
  @@index([created_at])
  @@index([file_number])
  @@index([phone])
  @@index([last_name])
  @@index([first_name, last_name])
  // OPTIMIZATION: GIN Indexes for efficient text search
  // Note: Requires "postgresqlExtensions" preview feature and "pg_trgm" extension in DB
  @@index([first_name], map: "idx_patient_firstname_search")
  @@index([last_name], map: "idx_patient_lastname_search")
  @@index([email], map: "idx_patient_email_search")
  @@index([phone], map: "idx_patient_phone_search")
}

// ============================================================================
// DOCTOR
// ============================================================================

model Doctor {
  id                        String  @id @default(uuid())
  user_id                   String  @unique // Link to User account (REQUIRED - Every Doctor MUST have a User)
  email                     String  @unique
  first_name                String
  last_name                 String
  title                     String? // Dr., Prof., etc.
  name                      String // Full display name
  specialization            String
  license_number            String  @unique
  phone                     String
  address                   String
  clinic_location           String? // Clinic address/location
  department                String?
  img                       String?
  profile_image             String? // URL or path to profile image
  colorCode                 String?
  availability_status       String? @default("AVAILABLE")
  type                      JOBTYPE @default(FULL)
  bio                       String? @db.Text // Brief biography
  education                 String? @db.Text // Educational background and qualifications
  focus_areas               String? @db.Text // Areas of expertise/focus
  professional_affiliations String? @db.Text // Professional memberships and affiliations

  // Onboarding State Machine (for non-self-registering doctors)
  onboarding_status    DoctorOnboardingStatus @default(INVITED)
  invited_at           DateTime?
  invited_by           String? // User ID of admin/frontdesk who invited
  activated_at         DateTime?
  profile_completed_at DateTime?

  // Relations
  user                     User                   @relation("DoctorUser", fields: [user_id], references: [id], onDelete: Cascade)
  working_days             WorkingDay[]
  appointments             Appointment[]
  ratings                  Rating[]
  diagnoses                Diagnosis[]            @relation("DiagnosisDoctor")
  consultations            Consultation[]
  medical_records          MedicalRecord[]        @relation("MedicalRecordDoctor")
  requesting_consultations DoctorConsultation[]   @relation("RequestingDoctor")
  consulting_consultations DoctorConsultation[]   @relation("ConsultingDoctor")
  consultation_messages    ConsultationMessage[]  @relation("ConsultationMessageSender")
  case_plans               CasePlan[]
  surgical_outcomes        SurgicalOutcome[]
  availability_overrides   AvailabilityOverride[]
  availability_breaks      AvailabilityBreak[]
  schedule_blocks          ScheduleBlock[]
  primary_surgical_cases   SurgicalCase[]         // New Architecture
  slot_configuration       SlotConfiguration?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([user_id])
  @@index([license_number])
  @@index([specialization])
  @@index([onboarding_status])
  @@index([invited_by])
  @@index([phone])
  @@index([name])
}

// ============================================================================
// DOCTOR INVITATION
// ============================================================================

model DoctorInviteToken {
  id             String    @id @default(uuid())
  doctor_id      String?   @unique // Links to Doctor when created
  email          String    @unique // Doctor's email address
  token          String    @unique // Secure random token for activation
  invited_by     String // User ID of admin/frontdesk who invited
  expires_at     DateTime // Token expiration (e.g., 7 days)
  used_at        DateTime? // When token was used for activation
  invalidated_at DateTime? // When token was revoked/cancelled

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([token])
  @@index([email])
  @@index([doctor_id])
  @@index([expires_at])
  @@index([invited_by])
}

model WorkingDay {
  id           Int     @id @default(autoincrement())
  doctor_id    String
  day          String // Monday, Tuesday, etc.
  start_time   String // HH:mm format (backward compatibility: used if no sessions exist)
  end_time     String // HH:mm format (backward compatibility: used if no sessions exist)
  is_available Boolean @default(true)

  doctor   Doctor              @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  breaks   AvailabilityBreak[] @relation("WorkingDayBreaks")
  sessions ScheduleSession[] // Multiple sessions per day (enterprise feature)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([doctor_id, day])
  @@index([doctor_id])
}

// ============================================================================
// AVAILABILITY MANAGEMENT
// ============================================================================

// One-off availability blocks (holidays, leave, emergency unavailability)
model AvailabilityOverride {
  id         String   @id @default(uuid())
  doctor_id  String
  start_date DateTime
  end_date   DateTime
  reason     String? // "Holiday", "Leave", "Emergency", etc.
  is_blocked Boolean  @default(true) // true = unavailable, false = available override
  start_time String? // HH:mm format - custom start time for this date (only for single-day overrides)
  end_time   String? // HH:mm format - custom end time for this date (only for single-day overrides)

  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([doctor_id])
  @@index([start_date, end_date])
  @@index([doctor_id, start_date, end_date])
}

// Recurring breaks (lunch, admin time, etc.)
model AvailabilityBreak {
  id             String  @id @default(uuid())
  doctor_id      String
  working_day_id Int? // If set, break applies to specific working day
  day_of_week    String? // If working_day_id is null, applies to this day of week (e.g., "Monday")
  start_time     String // HH:mm format
  end_time       String // HH:mm format
  reason         String? // "Lunch", "Break", "Admin Time", etc.

  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  working_day WorkingDay? @relation("WorkingDayBreaks", fields: [working_day_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([doctor_id])
  @@index([working_day_id])
  @@index([doctor_id, day_of_week])
}

// Multiple time sessions per working day (enterprise scheduling)
// Example: Monday can have 08:00-11:00 (Clinic) and 14:00-17:00 (Consultations)
model ScheduleSession {
  id             String  @id @default(uuid())
  working_day_id Int // Links to WorkingDay
  start_time     String // HH:mm format
  end_time       String // HH:mm format
  session_type   String? // "Clinic", "Ward Rounds", "Teleconsult", "Surgery", etc.
  max_patients   Int? // Optional: maximum appointments per session
  notes          String? // Optional notes about this session

  working_day WorkingDay @relation(fields: [working_day_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([working_day_id])
  @@index([start_time, end_time])
}

// Explicit blocked periods (leave, surgery, admin, emergency, etc.)
// Separate from AvailabilityOverride which is for custom hours
model ScheduleBlock {
  id         String   @id @default(uuid())
  doctor_id  String
  start_date DateTime // Start of block period
  end_date   DateTime // End of block period
  start_time String? // HH:mm - if null, entire day blocked
  end_time   String? // HH:mm - if null, entire day blocked
  block_type String // "LEAVE", "SURGERY", "ADMIN", "EMERGENCY", "CONFERENCE", "BURNOUT_PROTECTION", etc.
  reason     String? // Human-readable reason
  created_by String // User ID who created the block

  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([doctor_id])
  @@index([start_date, end_date])
  @@index([doctor_id, start_date, end_date])
}

// Slot configuration per doctor (appointment duration, buffer time, slot intervals)
model SlotConfiguration {
  id               String @id @default(uuid())
  doctor_id        String @unique
  default_duration Int    @default(30) // minutes (e.g., 30 = 30-minute appointments)
  buffer_time      Int    @default(0) // minutes between appointments (e.g., 5 = 5min buffer)
  slot_interval    Int    @default(15) // minutes (e.g., 15 = slots at 09:00, 09:15, 09:30, etc.)

  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([doctor_id])
}

// ============================================================================
// APPOINTMENT
// ============================================================================

model Appointment {
  id               Int               @id @default(autoincrement())
  patient_id       String
  doctor_id        String
  appointment_date DateTime
  time             String // HH:mm format
  status           AppointmentStatus @default(PENDING)
  type             String // Consultation, Follow-up, Procedure, etc.
  note             String?
  reason           String?
  checked_in_at    DateTime?
  checked_in_by    String? // User ID who checked in patient
  late_arrival     Boolean           @default(false)
  late_by_minutes  Int? // Minutes late if late_arrival is true

  // PHASE 1: Temporal Tracking (NEW)
  scheduled_at         DateTime? // Full datetime (canonical, replaces appointment_date + time)
  status_changed_at    DateTime  @default(now()) // When status was last changed
  status_changed_by    String? // User ID who changed status
  doctor_confirmed_at  DateTime? // When doctor explicitly confirmed
  doctor_confirmed_by  String? // Doctor ID who confirmed
  doctor_rejection_reason String? // Reason if doctor rejected

  // No-Show Tracking
  no_show                       Boolean   @default(false)
  no_show_at                    DateTime?
  no_show_reason                String? // 'AUTO', 'MANUAL', 'PATIENT_CALLED', etc.
  no_show_notes                 String?
  rescheduled_to_appointment_id Int? // If rescheduled after no-show
  marked_no_show_at             DateTime? // PHASE 1: When marked as no-show

  // Consultation Request Workflow (nullable for backward compatibility)
  consultation_request_status ConsultationRequestStatus?
  reviewed_by                 String? // User ID (Frontdesk who reviewed)
  reviewed_at                 DateTime?
  review_notes                String? // Notes from review (e.g., reason for needs_more_info)

  // Slot tracking (for availability-based scheduling)
  slot_start_time String? // HH:mm format of slot start time
  slot_duration   Int? @default(30) // PHASE 1: minutes (e.g., 30 = 30-minute appointment) - now required with default
  duration_minutes Int? // PHASE 1: Alternative duration field for clarity

  // Relations
  patient              Patient              @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor               Doctor               @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  payments             Payment[]
  medical_records      MedicalRecord[]
  care_notes           CareNote[]
  nurse_assignments    NurseAssignment[]    @relation("NurseAssignmentAppointment")
  vital_signs          VitalSign[]          @relation("VitalSignAppointment")
  doctor_consultations DoctorConsultation[] @relation("DoctorConsultationAppointment")
  case_plan            CasePlan?
  patient_images       PatientImage[]
  clinical_tasks       ClinicalTask[]
  surgical_outcome     SurgicalOutcome?
  consultation         Consultation?        @relation("AppointmentConsultation")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([doctor_id])
  @@index([appointment_date])
  @@index([status])
  @@index([appointment_date, status])
  @@index([doctor_id, appointment_date, time])
  @@index([consultation_request_status])
  @@index([reviewed_by])
  @@index([created_at])
  @@index([updated_at])
  
  // PHASE 1: Performance Indexes (NEW)
  @@index([doctor_id, scheduled_at]) // Doctor schedule queries
  @@index([doctor_id, status, scheduled_at]) // Doctor schedule with status filtering
  @@index([patient_id, scheduled_at]) // Patient appointment history
  @@index([patient_id, status, scheduled_at]) // Patient appointments with status
  @@index([status, created_at]) // Status-based queries
  @@index([status_changed_at]) // Audit trail queries
  @@index([status_changed_by]) // Track who changed status
  
  // Unique constraint for slot locking (prevent double-booking)
  @@unique([doctor_id, scheduled_at], map: "unique_doctor_scheduled_slot")
}

// ============================================================================
// CONSULTATION
// ============================================================================

model Consultation {
  id               Int       @id @default(autoincrement())
  appointment_id   Int       @unique
  doctor_id        String
  user_id          String? // User who started consultation
  started_at       DateTime?
  completed_at     DateTime?
  duration_minutes Int? // Calculated: completed_at - started_at
  doctor_notes     String?   @db.Text
  outcome          String? // Legacy field, use outcome_type instead
  outcome_type     String? // ConsultationOutcomeType: PROCEDURE_RECOMMENDED, CONSULTATION_ONLY, etc.
  patient_decision String? // 'YES', 'NO', 'PENDING' - if procedure recommended
  follow_up_date   DateTime?
  follow_up_type   String?
  follow_up_notes  String?

  // Relations
  surgical_case   SurgicalCase? // New Architecture
  appointment Appointment @relation("AppointmentConsultation", fields: [appointment_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  user        User?       @relation(fields: [user_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([appointment_id])
  @@index([doctor_id])
  @@index([started_at])
  @@index([completed_at])
  @@index([user_id])
}

// ============================================================================
// PRE/POST-OP WORKFLOWS
// ============================================================================

model NurseAssignment {
  id             Int      @id @default(autoincrement())
  patient_id     String
  nurse_user_id  String // User with NURSE role
  appointment_id Int?
  assigned_at    DateTime @default(now())
  assigned_by    String? // User ID who made assignment
  notes          String?

  // Relations
  patient     Patient      @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  nurse       User         @relation("NurseAssignments", fields: [nurse_user_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation("NurseAssignmentAppointment", fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([nurse_user_id])
  @@index([appointment_id])
}

model CareNote {
  id             Int          @id @default(autoincrement())
  patient_id     String
  nurse_user_id  String // User with NURSE role
  appointment_id Int?
  note_type      CareNoteType @default(GENERAL)
  note           String
  recorded_at    DateTime     @default(now())

  // Relations
  patient     Patient      @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  nurse       User         @relation("CareNoteNurse", fields: [nurse_user_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([nurse_user_id])
  @@index([appointment_id])
  @@index([note_type])
  @@index([recorded_at])
}

model VitalSign {
  id                Int      @id @default(autoincrement())
  patient_id        String
  appointment_id    Int?
  medical_record_id Int?
  body_temperature  Float? // Celsius
  systolic          Int? // mmHg
  diastolic         Int? // mmHg
  heart_rate        String? // bpm (can be range like "72-80")
  respiratory_rate  Int? // per minute
  oxygen_saturation Int? // percentage
  weight            Float? // kg
  height            Float? // cm
  recorded_by       String // User ID
  recorded_at       DateTime @default(now())

  // Relations
  patient        Patient        @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  medical_record MedicalRecord? @relation(fields: [medical_record_id], references: [id], onDelete: SetNull)
  appointment    Appointment?   @relation("VitalSignAppointment", fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([recorded_at])
}

// ============================================================================
// MEDICAL RECORDS
// ============================================================================

model MedicalRecord {
  id             Int     @id @default(autoincrement())
  patient_id     String
  appointment_id Int
  doctor_id      String
  treatment_plan String?
  prescriptions  String?
  lab_request    String?
  notes          String?

  // Relations
  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation("MedicalRecordDoctor", fields: [doctor_id], references: [id], onDelete: Cascade)
  lab_tests   LabTest[]
  vital_signs VitalSign[]
  diagnoses   Diagnosis[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([doctor_id])
  @@index([created_at])
}

model Diagnosis {
  id                     Int     @id @default(autoincrement())
  patient_id             String
  medical_record_id      Int
  doctor_id              String
  symptoms               String
  diagnosis              String
  notes                  String?
  prescribed_medications String?
  follow_up_plan         String?

  // Relations
  medical_record MedicalRecord @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  doctor         Doctor        @relation("DiagnosisDoctor", fields: [doctor_id], references: [id], onDelete: Cascade)
  patient        Patient       @relation("PatientDiagnosis", fields: [patient_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([medical_record_id])
  @@index([doctor_id])
}

model LabTest {
  id                Int      @id @default(autoincrement())
  medical_record_id Int
  test_date         DateTime
  result            String
  status            String
  notes             String?
  service_id        Int?     @unique

  // Relations
  medical_record MedicalRecord @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  service        Service?      @relation(fields: [service_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([medical_record_id])
  @@index([test_date])
}

// ============================================================================
// BILLING & PAYMENTS
// ============================================================================

model Payment {
  id             Int           @id @default(autoincrement())
  patient_id     String
  appointment_id Int           @unique
  bill_date      DateTime
  payment_date   DateTime?
  discount       Float         @default(0)
  total_amount   Float
  amount_paid    Float         @default(0)
  payment_method PaymentMethod @default(CASH)
  status         PaymentStatus @default(UNPAID)
  receipt_number String?       @unique

  // Relations
  appointment Appointment   @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient       @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  bill_items  PatientBill[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([status])
  @@index([payment_date])
  @@index([bill_date])
  @@index([created_at])
}

model PatientBill {
  id           Int      @id @default(autoincrement())
  payment_id   Int
  service_id   Int
  service_date DateTime
  quantity     Int      @default(1)
  unit_cost    Float
  total_cost   Float

  // Relations
  service Service @relation(fields: [service_id], references: [id], onDelete: Cascade)
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([payment_id])
  @@index([service_id])
}

model Service {
  id           Int     @id @default(autoincrement())
  service_name String
  description  String?
  price        Float
  category     String? // Procedure, Consultation, Lab Test, etc.
  is_active    Boolean @default(true)

  // Relations
  lab_test   LabTest?
  bill_items PatientBill[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([service_name])
  @@index([category])
  @@index([is_active])
}

// ============================================================================
// RATINGS & FEEDBACK
// ============================================================================

model Rating {
  id         Int     @id @default(autoincrement())
  doctor_id  String
  patient_id String
  rating     Int // 1-5 scale
  comment    String?

  // Relations
  doctor  Doctor  @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  patient Patient @relation(fields: [patient_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([doctor_id, patient_id])
  @@index([doctor_id])
  @@index([patient_id])
  @@index([rating])
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

model Notification {
  id        Int                @id @default(autoincrement())
  user_id   String? // Recipient user ID
  sender_id String? // Sender user ID
  type      NotificationType
  status    NotificationStatus @default(PENDING)
  subject   String?
  message   String
  metadata  String? // JSON string for additional data
  sent_at   DateTime?
  read_at   DateTime?

  // Relations
  recipient User? @relation("NotificationRecipient", fields: [user_id], references: [id], onDelete: Cascade)
  sender    User? @relation("NotificationSender", fields: [sender_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([status])
  @@index([type])
  @@index([sent_at])
}

// ============================================================================
// AUDIT LOGS
// ============================================================================

model AuditLog {
  id         Int     @id @default(autoincrement())
  user_id    String? // User who performed the action
  record_id  String // ID of the affected record
  action     String // CREATE, UPDATE, DELETE, VIEW, LOGIN, LOGOUT, etc.
  model      String // Model/table name
  details    String? // Additional details (JSON string)
  ip_address String?
  user_agent String?

  // Relations
  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([model])
  @@index([action])
  @@index([created_at])
  @@index([user_id, created_at])
}

// ============================================================================
// SURGEON-SPECIFIC FEATURES
// ============================================================================

// Doctor-to-Doctor Consultations
model DoctorConsultation {
  id                   String         @id @default(uuid())
  case_id              Int? // Optional: link to appointment/patient case
  patient_id           String? // Optional: attached patient
  requesting_doctor_id String // Doctor who requested consultation
  consulting_doctor_id String // Doctor being consulted
  urgency              ConsultUrgency @default(ROUTINE)
  status               ConsultStatus  @default(OPEN)
  subject              String
  question             String         @db.Text
  background           String?        @db.Text
  what_is_needed       String?        @db.Text // opinion, approval, second opinion
  response             String?        @db.Text
  resolved_at          DateTime?
  resolved_by          String?

  // Relations
  requesting_doctor Doctor                   @relation("RequestingDoctor", fields: [requesting_doctor_id], references: [id], onDelete: Cascade)
  consulting_doctor Doctor                   @relation("ConsultingDoctor", fields: [consulting_doctor_id], references: [id], onDelete: Cascade)
  patient           Patient?                 @relation(fields: [patient_id], references: [id], onDelete: SetNull)
  appointment       Appointment?             @relation("DoctorConsultationAppointment", fields: [case_id], references: [id], onDelete: SetNull)
  attachments       ConsultationAttachment[]
  messages          ConsultationMessage[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([requesting_doctor_id])
  @@index([consulting_doctor_id])
  @@index([patient_id])
  @@index([case_id])
  @@index([status])
  @@index([urgency])
  @@index([created_at])
}

model ConsultationAttachment {
  id              Int     @id @default(autoincrement())
  consultation_id String
  file_url        String
  file_name       String
  file_type       String? // image, scan, document, etc.
  file_size       Int? // bytes
  description     String?

  consultation DoctorConsultation @relation(fields: [consultation_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([consultation_id])
}

model ConsultationMessage {
  id              Int     @id @default(autoincrement())
  consultation_id String
  sender_id       String // Doctor ID
  message         String  @db.Text
  is_internal     Boolean @default(true) // Internal note vs patient-facing

  consultation DoctorConsultation @relation(fields: [consultation_id], references: [id], onDelete: Cascade)
  sender       Doctor             @relation("ConsultationMessageSender", fields: [sender_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([consultation_id])
  @@index([sender_id])
  @@index([created_at])
}

// Surgical Case Planning Workspace
model CasePlan {
  id                   Int                 @id @default(autoincrement())
  appointment_id       Int                 @unique // Legacy link
  surgical_case_id     String?             @unique // New architecture link
  patient_id           String
  doctor_id            String
  procedure_plan       String?             @db.Text
  risk_factors         String?             @db.Text // JSON or structured text
  pre_op_notes         String?             @db.Text
  implant_details      String?             @db.Text // Brand, size, model, etc.
  marking_diagram      String? // URL to diagram/image
  consent_checklist    String?             @db.Text // JSON array of consent items
  planned_anesthesia   String?
  special_instructions String?             @db.Text // Instructions to theatre team
  readiness_status     CaseReadinessStatus @default(NOT_STARTED)
  ready_for_surgery    Boolean             @default(false)

  // Relations
  surgical_case    SurgicalCase?            @relation(fields: [surgical_case_id], references: [id], onDelete: SetNull)
  appointment      Appointment              @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient          Patient                  @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor           Doctor                   @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  images           PatientImage[]
  procedure_record SurgicalProcedureRecord?
  consents         ConsentForm[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([appointment_id])
  @@index([patient_id])
  @@index([doctor_id])
  @@index([readiness_status])
}

model SurgicalProcedureRecord {
  id                  Int       @id @default(autoincrement())
  case_plan_id        Int?      @unique // Legacy
  surgical_case_id    String?   @unique // New Architecture
  
  // Relations
  surgical_case       SurgicalCase? @relation(fields: [surgical_case_id], references: [id], onDelete: Cascade)

  // Clinical Details
  pre_op_diagnosis    String    @db.Text
  post_op_diagnosis   String?   @db.Text
  procedure_performed String?   @db.Text
  
  // Logistics
  urgency             SurgicalUrgency @default(ELECTIVE)
  theater_id          String?
  
  // Timestamps (Audit)
  anesthesia_start    DateTime?
  incision_time       DateTime?
  closure_time        DateTime?
  wheels_out          DateTime?

  // Prep Details
  shaving_required    Boolean   @default(false)
  shaving_extent      String?
  skin_prep_agent     String?

  // Anesthesia
  anesthesia_type     AnesthesiaType?
  asa_score           Int?

  // Classification
  wound_class         WoundClassification?

  // Staffing
  staff               SurgicalStaff[]

  // Relations
  case_plan           CasePlan? @relation(fields: [case_plan_id], references: [id], onDelete: SetNull)
  theater             Theater?  @relation(fields: [theater_id], references: [id], onDelete: SetNull)

  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt

  @@index([case_plan_id])
  @@index([theater_id])
}

model SurgicalStaff {
  id                  Int       @id @default(autoincrement())
  procedure_record_id Int
  user_id             String
  role                SurgicalRole
  notes               String?

  // Relations
  procedure_record    SurgicalProcedureRecord @relation(fields: [procedure_record_id], references: [id], onDelete: Cascade)
  user                User      @relation(fields: [user_id], references: [id])

  @@index([procedure_record_id])
  @@index([user_id])
}

model ConsentForm {
  id                  String    @id @default(uuid())
  case_plan_id        Int

  // Document details
  title               String
  type                ConsentType
  content_snapshot    String    @db.Text // Immutable copy
  version             Int       @default(1)

  // Status
  status              ConsentStatus @default(DRAFT)

  // Signatures
  patient_signature   String?   @db.Text
  signed_at           DateTime?
  signed_by_ip        String?

  witness_signature   String?   @db.Text
  witness_name        String?
  witness_id          String?

  // Expiry
  valid_until         DateTime?

  // Relations
  case_plan           CasePlan  @relation(fields: [case_plan_id], references: [id], onDelete: Cascade)
  witness_user        User?     @relation(fields: [witness_id], references: [id])

  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt

  @@index([case_plan_id])
  @@index([status])
}

// Before & After Image Management
model PatientImage {
  id                    Int            @id @default(autoincrement())
  patient_id            String
  appointment_id        Int?
  case_plan_id          Int?
  image_url             String
  thumbnail_url         String?
  angle                 ImageAngle
  timepoint             ImageTimepoint
  custom_timepoint      String? // For CUSTOM timepoint
  description           String?
  consent_for_marketing Boolean        @default(false)
  taken_by              String? // User ID
  taken_at              DateTime       @default(now())

  // Relations
  patient     Patient      @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)
  case_plan   CasePlan?    @relation(fields: [case_plan_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([timepoint])
  @@index([angle])
  @@index([taken_at])
}

// Clinical Note Templates
model ClinicalNoteTemplate {
  id               Int     @id @default(autoincrement())
  name             String
  template_type    String // CONSULTATION, PROCEDURE, POST_OP, COMPLICATION
  template_content String  @db.Text // Structured template with placeholders
  is_active        Boolean @default(true)
  created_by       String? // User ID
  used_count       Int     @default(0)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([template_type])
  @@index([is_active])
}

// Task & Delegation System
model ClinicalTask {
  id               Int          @id @default(autoincrement())
  patient_id       String?
  appointment_id   Int?
  assigned_by      String // User ID who created task
  assigned_to      String // User ID who should complete task
  task_type        String // FOLLOW_UP, UPLOAD_PHOTOS, CONFIRM_LABS, etc.
  title            String
  description      String?      @db.Text
  priority         TaskPriority @default(MEDIUM)
  status           TaskStatus   @default(PENDING)
  due_date         DateTime?
  completed_at     DateTime?
  completion_notes String?      @db.Text

  // Relations
  patient     Patient?     @relation(fields: [patient_id], references: [id], onDelete: SetNull)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([assigned_to])
  @@index([assigned_by])
  @@index([patient_id])
  @@index([appointment_id])
  @@index([status])
  @@index([priority])
  @@index([due_date])
}

// Surgical Outcome Tracking
model SurgicalOutcome {
  id                   Int           @id @default(autoincrement())
  appointment_id       Int           @unique
  patient_id           String
  doctor_id            String
  procedure_type       String
  outcome_status       OutcomeStatus
  complication_rate    Float? // 0-1 scale
  revision_required    Boolean       @default(false)
  revision_date        DateTime?
  patient_satisfaction Int? // 1-5 scale
  healing_timeline     String?       @db.Text
  notes                String?       @db.Text
  recorded_at          DateTime      @default(now())
  recorded_by          String // User ID

  // Relations
  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([appointment_id])
  @@index([patient_id])
  @@index([doctor_id])
  @@index([procedure_type])
  @@index([outcome_status])
  @@index([recorded_at])
}


// ============================================================================
// CLINIC MANAGEMENT (ADMIN GOVERNANCE)
// ============================================================================

model Clinic {
  id             String  @id @default(uuid())
  name           String  @default("Nairobi Sculpt Surgical Aesthetic Center")
  address        String?
  phone          String?
  email          String?
  website        String?
  logo_url       String?
  
  // Settings
  primary_color  String? @default("#4F46E5") // Indigo-600
  accent_color   String? 
  
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
}

model Theater {
  id             String  @id @default(uuid())
  name           String  // e.g. "Theater A (Major)"
  type           String  // "MAJOR", "MINOR", "PROCEDURE_ROOM"
  status         Status  @default(ACTIVE)
  color_code     String? // For scheduling UI
  notes          String?
  
  // Capabilities & Scheduling
  is_active        Boolean @default(true)
  operational_hours String? @db.Text // JSON: {"Mon": "08:00-18:00"}
  capabilities      String? @db.Text // JSON array: ["General Anesthesia", "X-Ray"]

  surgical_records SurgicalProcedureRecord[]
  bookings         TheaterBooking[]

  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
}

model ConsentTemplate {
  id             String      @id @default(uuid())
  title          String
  type           ConsentType
  content        String      @db.Text // HTML or Markdown content
  version        Int         @default(1)
  is_active      Boolean     @default(true)
  created_by     String?     // User ID

  created_at     DateTime    @default(now())
  updated_at     DateTime    @updatedAt

  @@index([type])
  @@index([is_active])
}

// ============================================================================
// PATIENT INTAKE SYSTEM
// ============================================================================

// Tracks patient intake sessions initiated by frontdesk
model IntakeSession {
  id                 String   @id @default(cuid())
  session_id         String   @unique // UUID
  status             String   @default("ACTIVE") // ACTIVE, SUBMITTED, CONFIRMED, EXPIRED
  created_at         DateTime @default(now())
  expires_at         DateTime
  created_by_user_id String? // Frontdesk user who initiated

  // Relations
  submissions IntakeSubmission[]

  @@index([session_id])
  @@index([expires_at])
  @@index([status])
  @@map("intake_session")
}

// Stores submitted patient intake forms
model IntakeSubmission {
  id                     String   @id @default(cuid())
  submission_id          String   @unique // Matches domain entity ID
  session_id             String   // One submission per session
  session                IntakeSession @relation(fields: [session_id], references: [session_id], onDelete: Cascade)

  // Personal Information
  first_name             String
  last_name              String
  date_of_birth          DateTime
  gender                 Gender

  // Contact Information
  email                  String
  phone                  String
  whatsapp_phone         String?
  address                String
  marital_status         String // SINGLE, MARRIED, DIVORCED, WIDOWED
  occupation             String?

  // Emergency Contact
  emergency_contact_name     String
  emergency_contact_number   String
  relation                   String // SPOUSE, PARENT, CHILD, SIBLING, FRIEND, OTHER

  // Medical Information
  blood_group            String? // O+, O-, A+, A-, B+, B-, AB+, AB-
  allergies              String? @db.Text
  medical_conditions     String? @db.Text
  medical_history        String? @db.Text

  // Insurance
  insurance_provider     String?
  insurance_number       String?

  // Consent (Required)
  privacy_consent        Boolean
  service_consent        Boolean
  medical_consent        Boolean

  // Audit
  submitted_at           DateTime @default(now())
  ip_address             String?
  user_agent             String? @db.Text

  // Status
  status                 String @default("PENDING") // PENDING, CONFIRMED, REJECTED
  created_patient_id     String? // References Patient(id) after confirmation
  confirmed_at           DateTime?
  confirmed_by_user_id   String?

  created_at             DateTime @default(now())
  updated_at             DateTime @updatedAt

  @@unique([session_id])
  @@index([session_id])
  @@index([status])
  @@index([submitted_at])
  @@index([created_patient_id])
  @@map("intake_submission")
}

// ============================================================================
// SURGICAL CASE MANAGEMENT (NEW ARCHITECTURE)
// ============================================================================

enum SurgicalCaseStatus {
  DRAFT
  PLANNING
  READY_FOR_SCHEDULING
  SCHEDULED
  IN_PREP
  IN_THEATER
  RECOVERY
  COMPLETED
  CANCELLED
}

enum TheaterBookingStatus {
  PROVISIONAL
  CONFIRMED
  CANCELLED
  COMPLETED
}

model SurgicalCase {
  id                  String             @id @default(uuid())
  patient_id          String
  primary_surgeon_id  String
  consultation_id     Int?               @unique // Originating consultation
  urgency             SurgicalUrgency    @default(ELECTIVE)
  status              SurgicalCaseStatus @default(DRAFT)
  
  // Clinical Data
  diagnosis           String?            @db.Text
  procedure_name      String?
  side                String?            // Left, Right, Bilateral, N/A
  
  // Scheduling
  theater_booking     TheaterBooking?
  
  // Relations
  patient             Patient            @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  primary_surgeon     Doctor             @relation(fields: [primary_surgeon_id], references: [id], onDelete: Cascade)
  consultation        Consultation?      @relation(fields: [consultation_id], references: [id], onDelete: SetNull)
  case_plan           CasePlan?
  procedure_record    SurgicalProcedureRecord? // One active record per case usually
  
  // Audit
  created_at          DateTime           @default(now())
  updated_at          DateTime           @updatedAt
  created_by          String?            // User ID

  @@index([patient_id])
  @@index([primary_surgeon_id])
  @@index([status])
  @@index([created_at])
}

model TheaterBooking {
  id              String               @id @default(uuid())
  theater_id      String
  surgical_case_id String              @unique
  start_time      DateTime
  end_time        DateTime
  status          TheaterBookingStatus @default(PROVISIONAL)
  
  // Locking
  locked_by       String?              // User ID who holds the lock
  locked_at       DateTime?
  
  // Relations
  theater         Theater              @relation(fields: [theater_id], references: [id], onDelete: Cascade)
  surgical_case   SurgicalCase         @relation(fields: [surgical_case_id], references: [id], onDelete: Cascade)
  
  created_at      DateTime             @default(now())
  updated_at      DateTime             @updatedAt

  @@index([theater_id])
  @@index([start_time, end_time])
  @@index([status])
  // Prevent double booking overlap in application logic, DB constraint harder for ranges without exclusion constraint support in raw prisma
}

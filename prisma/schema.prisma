// Prisma Schema for Nairobi Sculpt Surgical Aesthetic Clinic
// PostgreSQL Database Schema with full relational integrity

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  ADMIN
  NURSE
  DOCTOR
  LAB_TECHNICIAN
  PATIENT
  CASHIER
  FRONTDESK
}

enum Status {
  ACTIVE
  INACTIVE
  DORMANT
}

enum JOBTYPE {
  FULL
  PART
}

enum Gender {
  MALE
  FEMALE
}

enum AppointmentStatus {
  PENDING
  SCHEDULED
  CANCELLED
  COMPLETED
}

enum ConsultationRequestStatus {
  SUBMITTED
  PENDING_REVIEW
  NEEDS_MORE_INFO
  APPROVED
  SCHEDULED
  CONFIRMED
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  BANK_TRANSFER
}

enum PaymentStatus {
  PAID
  UNPAID
  PART
}

enum CareNoteType {
  PRE_OP
  POST_OP
  GENERAL
}

enum NotificationType {
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  READ
}

enum DoctorOnboardingStatus {
  INVITED
  ACTIVATED
  PROFILE_COMPLETED
  ACTIVE
}

enum ConsultUrgency {
  ROUTINE
  URGENT
  INTRA_OP
}

enum ConsultStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum ImageTimepoint {
  PRE_OP
  ONE_WEEK_POST_OP
  ONE_MONTH_POST_OP
  THREE_MONTHS_POST_OP
  SIX_MONTHS_POST_OP
  ONE_YEAR_POST_OP
  CUSTOM
}

enum ImageAngle {
  FRONT
  OBLIQUE_LEFT
  OBLIQUE_RIGHT
  PROFILE_LEFT
  PROFILE_RIGHT
  BACK
  TOP
  BOTTOM
  CUSTOM
}

enum CaseReadinessStatus {
  NOT_STARTED
  PENDING_LABS
  PENDING_CONSENT
  PENDING_REVIEW
  READY
  ON_HOLD
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum OutcomeStatus {
  EXCELLENT
  GOOD
  SATISFACTORY
  NEEDS_REVISION
  COMPLICATION
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password_hash String
  role          Role
  status        Status    @default(ACTIVE)
  mfa_enabled   Boolean   @default(false)
  mfa_secret    String?
  first_name    String?
  last_name     String?
  phone         String?
  last_login_at DateTime?

  // Relations
  refresh_tokens         RefreshToken[]
  audit_logs             AuditLog[]
  notifications_sent     Notification[]    @relation("NotificationSender")
  notifications_received Notification[]    @relation("NotificationRecipient")
  patient_profile        Patient?          @relation("PatientUser")
  doctor_profile         Doctor?           @relation("DoctorUser") // Optional: User may not have Doctor profile, but Doctor MUST have User
  assigned_patients      Patient[]         @relation("PatientAssignment")
  nurse_assignments      NurseAssignment[] @relation("NurseAssignments")
  care_notes             CareNote[]        @relation("CareNoteNurse")
  consultations          Consultation[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([role])
  @@index([status])
  @@index([role, status])
}

model RefreshToken {
  id         Int       @id @default(autoincrement())
  user_id    String
  token      String    @unique
  expires_at DateTime
  revoked    Boolean   @default(false)
  revoked_at DateTime?

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([token])
  @@index([expires_at])
  @@index([user_id, revoked])
}

// ============================================================================
// PATIENT
// ============================================================================

model Patient {
  id                       String    @id @default(uuid())
  file_number              String    @unique // System-generated: NS001, NS002, NS003, etc.
  user_id                  String?   @unique // Link to User if patient has account
  first_name               String
  last_name                String
  date_of_birth            DateTime
  gender                   Gender    @default(FEMALE)
  phone                    String
  whatsapp_phone           String? // WhatsApp contact number (optional)
  email                    String    @unique
  marital_status           String
  occupation               String? // Patient's occupation (optional)
  address                  String
  emergency_contact_name   String
  emergency_contact_number String
  relation                 String
  blood_group              String?
  allergies                String?
  medical_conditions       String?
  medical_history          String?
  insurance_provider       String?
  insurance_number         String?
  privacy_consent          Boolean   @default(false)
  service_consent          Boolean   @default(false)
  medical_consent          Boolean   @default(false)
  img                      String?
  colorCode                String?
  approved                 Boolean   @default(false)
  approved_by              String?
  approved_at              DateTime?
  assigned_to_user_id      String? // Assigned staff member

  // Relations
  user              User?             @relation("PatientUser", fields: [user_id], references: [id], onDelete: SetNull)
  assigned_to       User?             @relation("PatientAssignment", fields: [assigned_to_user_id], references: [id], onDelete: SetNull)
  appointments      Appointment[]
  medical_records   MedicalRecord[]
  payments          Payment[]
  ratings           Rating[]
  nurse_assignments NurseAssignment[]
  care_notes        CareNote[]
  vital_signs       VitalSign[]
  diagnoses         Diagnosis[]       @relation("PatientDiagnosis")
  doctor_consultations DoctorConsultation[]
  case_plans          CasePlan[]
  patient_images      PatientImage[]
  clinical_tasks      ClinicalTask[]
  surgical_outcomes   SurgicalOutcome[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([user_id])
  @@index([assigned_to_user_id])
  @@index([approved])
  @@index([created_at])
  @@index([file_number])
  @@index([phone])
  @@index([last_name])
  @@index([first_name, last_name])
}

// ============================================================================
// DOCTOR
// ============================================================================

model Doctor {
  id                        String  @id @default(uuid())
  user_id                   String  @unique // Link to User account (REQUIRED - Every Doctor MUST have a User)
  email                     String  @unique
  first_name                String
  last_name                 String
  title                     String? // Dr., Prof., etc.
  name                      String // Full display name
  specialization            String
  license_number            String  @unique
  phone                     String
  address                   String
  clinic_location           String? // Clinic address/location
  department                String?
  img                       String?
  profile_image             String? // URL or path to profile image
  colorCode                 String?
  availability_status       String? @default("AVAILABLE")
  type                      JOBTYPE @default(FULL)
  bio                       String? @db.Text // Brief biography
  education                 String? @db.Text // Educational background and qualifications
  focus_areas               String? @db.Text // Areas of expertise/focus
  professional_affiliations String? @db.Text // Professional memberships and affiliations

  // Onboarding State Machine (for non-self-registering doctors)
  onboarding_status    DoctorOnboardingStatus @default(INVITED)
  invited_at           DateTime?
  invited_by           String? // User ID of admin/frontdesk who invited
  activated_at         DateTime?
  profile_completed_at DateTime?

  // Relations
  user            User            @relation("DoctorUser", fields: [user_id], references: [id], onDelete: Cascade)
  working_days    WorkingDay[]
  appointments    Appointment[]
  ratings         Rating[]
  diagnoses       Diagnosis[]     @relation("DiagnosisDoctor")
  consultations   Consultation[]
  medical_records MedicalRecord[] @relation("MedicalRecordDoctor")
  requesting_consultations DoctorConsultation[] @relation("RequestingDoctor")
  consulting_consultations DoctorConsultation[] @relation("ConsultingDoctor")
  consultation_messages     ConsultationMessage[] @relation("ConsultationMessageSender")
  case_plans                CasePlan[]
  surgical_outcomes         SurgicalOutcome[]
  availability_overrides    AvailabilityOverride[]
  availability_breaks       AvailabilityBreak[]
  slot_configuration        SlotConfiguration?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([email])
  @@index([user_id])
  @@index([license_number])
  @@index([specialization])
  @@index([onboarding_status])
  @@index([invited_by])
  @@index([phone])
  @@index([name])
}

// ============================================================================
// DOCTOR INVITATION
// ============================================================================

model DoctorInviteToken {
  id             String    @id @default(uuid())
  doctor_id      String?   @unique // Links to Doctor when created
  email          String    @unique // Doctor's email address
  token          String    @unique // Secure random token for activation
  invited_by     String // User ID of admin/frontdesk who invited
  expires_at     DateTime // Token expiration (e.g., 7 days)
  used_at        DateTime? // When token was used for activation
  invalidated_at DateTime? // When token was revoked/cancelled

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([token])
  @@index([email])
  @@index([doctor_id])
  @@index([expires_at])
  @@index([invited_by])
}

model WorkingDay {
  id           Int     @id @default(autoincrement())
  doctor_id    String
  day          String // Monday, Tuesday, etc.
  start_time   String // HH:mm format
  end_time     String // HH:mm format
  is_available Boolean @default(true)

  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  breaks AvailabilityBreak[] @relation("WorkingDayBreaks")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([doctor_id, day])
  @@index([doctor_id])
}

// ============================================================================
// AVAILABILITY MANAGEMENT
// ============================================================================

// One-off availability blocks (holidays, leave, emergency unavailability)
model AvailabilityOverride {
  id         String   @id @default(uuid())
  doctor_id  String
  start_date DateTime
  end_date   DateTime
  reason     String?  // "Holiday", "Leave", "Emergency", etc.
  is_blocked Boolean  @default(true) // true = unavailable, false = available override

  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([doctor_id])
  @@index([start_date, end_date])
  @@index([doctor_id, start_date, end_date])
}

// Recurring breaks (lunch, admin time, etc.)
model AvailabilityBreak {
  id            String      @id @default(uuid())
  doctor_id    String
  working_day_id Int?       // If set, break applies to specific working day
  day_of_week  String?      // If working_day_id is null, applies to this day of week (e.g., "Monday")
  start_time   String       // HH:mm format
  end_time     String       // HH:mm format
  reason       String?      // "Lunch", "Break", "Admin Time", etc.

  doctor       Doctor       @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  working_day  WorkingDay?  @relation("WorkingDayBreaks", fields: [working_day_id], references: [id], onDelete: Cascade)

  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt

  @@index([doctor_id])
  @@index([working_day_id])
  @@index([doctor_id, day_of_week])
}

// Slot configuration per doctor (appointment duration, buffer time, slot intervals)
model SlotConfiguration {
  id              String  @id @default(uuid())
  doctor_id       String  @unique
  default_duration Int    @default(30) // minutes (e.g., 30 = 30-minute appointments)
  buffer_time     Int     @default(0)  // minutes between appointments (e.g., 5 = 5min buffer)
  slot_interval   Int     @default(15) // minutes (e.g., 15 = slots at 09:00, 09:15, 09:30, etc.)

  doctor          Doctor  @relation(fields: [doctor_id], references: [id], onDelete: Cascade)

  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  @@index([doctor_id])
}

// ============================================================================
// APPOINTMENT
// ============================================================================

model Appointment {
  id               Int               @id @default(autoincrement())
  patient_id       String
  doctor_id        String
  appointment_date DateTime
  time             String // HH:mm format
  status           AppointmentStatus @default(PENDING)
  type             String // Consultation, Follow-up, Procedure, etc.
  note             String?
  reason           String?
  checked_in_at    DateTime?
  checked_in_by    String? // User ID who checked in patient
  late_arrival     Boolean   @default(false)
  late_by_minutes  Int? // Minutes late if late_arrival is true
  
  // No-Show Tracking
  no_show          Boolean   @default(false)
  no_show_at       DateTime?
  no_show_reason   String? // 'AUTO', 'MANUAL', 'PATIENT_CALLED', etc.
  no_show_notes    String?
  rescheduled_to_appointment_id Int? // If rescheduled after no-show

  // Consultation Request Workflow (nullable for backward compatibility)
  consultation_request_status ConsultationRequestStatus?
  reviewed_by                 String? // User ID (Frontdesk who reviewed)
  reviewed_at                 DateTime?
  review_notes                String? // Notes from review (e.g., reason for needs_more_info)

  // Slot tracking (for availability-based scheduling)
  slot_start_time  String? // HH:mm format of slot start time
  slot_duration    Int?    // minutes (e.g., 30 = 30-minute appointment)

  // Relations
  patient           Patient           @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor            Doctor            @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  payments          Payment[]
  medical_records   MedicalRecord[]
  care_notes        CareNote[]
  nurse_assignments NurseAssignment[] @relation("NurseAssignmentAppointment")
  vital_signs       VitalSign[]       @relation("VitalSignAppointment")
  doctor_consultations DoctorConsultation[] @relation("DoctorConsultationAppointment")
  case_plan            CasePlan?
  patient_images       PatientImage[]
  clinical_tasks       ClinicalTask[]
  surgical_outcome     SurgicalOutcome?
  consultation         Consultation? @relation("AppointmentConsultation")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([doctor_id])
  @@index([appointment_date])
  @@index([status])
  @@index([appointment_date, status])
  @@index([doctor_id, appointment_date, time])
  @@index([consultation_request_status])
  @@index([reviewed_by])
  @@index([created_at])
  @@index([updated_at])
}

// ============================================================================
// CONSULTATION
// ============================================================================

model Consultation {
  id              Int       @id @default(autoincrement())
  appointment_id  Int       @unique
  doctor_id       String
  user_id         String? // User who started consultation
  started_at      DateTime?
  completed_at    DateTime?
  duration_minutes Int? // Calculated: completed_at - started_at
  doctor_notes    String? @db.Text
  outcome         String? // Legacy field, use outcome_type instead
  outcome_type    String? // ConsultationOutcomeType: PROCEDURE_RECOMMENDED, CONSULTATION_ONLY, etc.
  patient_decision String? // 'YES', 'NO', 'PENDING' - if procedure recommended
  follow_up_date  DateTime?
  follow_up_type  String?
  follow_up_notes String?

  // Relations
  appointment Appointment @relation("AppointmentConsultation", fields: [appointment_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  user        User?       @relation(fields: [user_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([appointment_id])
  @@index([doctor_id])
  @@index([started_at])
  @@index([completed_at])
  @@index([user_id])
}

// ============================================================================
// PRE/POST-OP WORKFLOWS
// ============================================================================

model NurseAssignment {
  id             Int      @id @default(autoincrement())
  patient_id     String
  nurse_user_id  String // User with NURSE role
  appointment_id Int?
  assigned_at    DateTime @default(now())
  assigned_by    String? // User ID who made assignment
  notes          String?

  // Relations
  patient     Patient      @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  nurse       User         @relation("NurseAssignments", fields: [nurse_user_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation("NurseAssignmentAppointment", fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([nurse_user_id])
  @@index([appointment_id])
}

model CareNote {
  id             Int          @id @default(autoincrement())
  patient_id     String
  nurse_user_id  String // User with NURSE role
  appointment_id Int?
  note_type      CareNoteType @default(GENERAL)
  note           String
  recorded_at    DateTime     @default(now())

  // Relations
  patient     Patient      @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  nurse       User         @relation("CareNoteNurse", fields: [nurse_user_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([nurse_user_id])
  @@index([appointment_id])
  @@index([note_type])
  @@index([recorded_at])
}

model VitalSign {
  id                Int      @id @default(autoincrement())
  patient_id        String
  appointment_id    Int?
  medical_record_id Int?
  body_temperature  Float? // Celsius
  systolic          Int? // mmHg
  diastolic         Int? // mmHg
  heart_rate        String? // bpm (can be range like "72-80")
  respiratory_rate  Int? // per minute
  oxygen_saturation Int? // percentage
  weight            Float? // kg
  height            Float? // cm
  recorded_by       String // User ID
  recorded_at       DateTime @default(now())

  // Relations
  patient        Patient        @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  medical_record MedicalRecord? @relation(fields: [medical_record_id], references: [id], onDelete: SetNull)
  appointment    Appointment?   @relation("VitalSignAppointment", fields: [appointment_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([recorded_at])
}

// ============================================================================
// MEDICAL RECORDS
// ============================================================================

model MedicalRecord {
  id             Int     @id @default(autoincrement())
  patient_id     String
  appointment_id Int
  doctor_id      String
  treatment_plan String?
  prescriptions  String?
  lab_request    String?
  notes          String?

  // Relations
  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation("MedicalRecordDoctor", fields: [doctor_id], references: [id], onDelete: Cascade)
  lab_tests   LabTest[]
  vital_signs VitalSign[]
  diagnoses   Diagnosis[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([doctor_id])
  @@index([created_at])
}

model Diagnosis {
  id                     Int     @id @default(autoincrement())
  patient_id             String
  medical_record_id      Int
  doctor_id              String
  symptoms               String
  diagnosis              String
  notes                  String?
  prescribed_medications String?
  follow_up_plan         String?

  // Relations
  medical_record MedicalRecord @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  doctor         Doctor        @relation("DiagnosisDoctor", fields: [doctor_id], references: [id], onDelete: Cascade)
  patient        Patient       @relation("PatientDiagnosis", fields: [patient_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([medical_record_id])
  @@index([doctor_id])
}

model LabTest {
  id                Int      @id @default(autoincrement())
  medical_record_id Int
  test_date         DateTime
  result            String
  status            String
  notes             String?
  service_id        Int?     @unique

  // Relations
  medical_record MedicalRecord @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  service        Service?      @relation(fields: [service_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([medical_record_id])
  @@index([test_date])
}

// ============================================================================
// BILLING & PAYMENTS
// ============================================================================

model Payment {
  id             Int           @id @default(autoincrement())
  patient_id     String
  appointment_id Int           @unique
  bill_date      DateTime
  payment_date   DateTime?
  discount       Float         @default(0)
  total_amount   Float
  amount_paid    Float         @default(0)
  payment_method PaymentMethod @default(CASH)
  status         PaymentStatus @default(UNPAID)
  receipt_number String?       @unique

  // Relations
  appointment Appointment   @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient       @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  bill_items  PatientBill[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([patient_id])
  @@index([appointment_id])
  @@index([status])
  @@index([payment_date])
  @@index([bill_date])
  @@index([created_at])
}

model PatientBill {
  id           Int      @id @default(autoincrement())
  payment_id   Int
  service_id   Int
  service_date DateTime
  quantity     Int      @default(1)
  unit_cost    Float
  total_cost   Float

  // Relations
  service Service @relation(fields: [service_id], references: [id], onDelete: Cascade)
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([payment_id])
  @@index([service_id])
}

model Service {
  id           Int     @id @default(autoincrement())
  service_name String
  description  String?
  price        Float
  category     String? // Procedure, Consultation, Lab Test, etc.
  is_active    Boolean @default(true)

  // Relations
  lab_test   LabTest?
  bill_items PatientBill[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([service_name])
  @@index([category])
  @@index([is_active])
}

// ============================================================================
// RATINGS & FEEDBACK
// ============================================================================

model Rating {
  id         Int     @id @default(autoincrement())
  doctor_id  String
  patient_id String
  rating     Int // 1-5 scale
  comment    String?

  // Relations
  doctor  Doctor  @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  patient Patient @relation(fields: [patient_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([doctor_id, patient_id])
  @@index([doctor_id])
  @@index([patient_id])
  @@index([rating])
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

model Notification {
  id        Int                @id @default(autoincrement())
  user_id   String? // Recipient user ID
  sender_id String? // Sender user ID
  type      NotificationType
  status    NotificationStatus @default(PENDING)
  subject   String?
  message   String
  metadata  String? // JSON string for additional data
  sent_at   DateTime?
  read_at   DateTime?

  // Relations
  recipient User? @relation("NotificationRecipient", fields: [user_id], references: [id], onDelete: Cascade)
  sender    User? @relation("NotificationSender", fields: [sender_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([status])
  @@index([type])
  @@index([sent_at])
}

// ============================================================================
// AUDIT LOGS
// ============================================================================

model AuditLog {
  id         Int     @id @default(autoincrement())
  user_id    String? // User who performed the action
  record_id  String // ID of the affected record
  action     String // CREATE, UPDATE, DELETE, VIEW, LOGIN, LOGOUT, etc.
  model      String // Model/table name
  details    String? // Additional details (JSON string)
  ip_address String?
  user_agent String?

  // Relations
  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([user_id])
  @@index([model])
  @@index([action])
  @@index([created_at])
  @@index([user_id, created_at])
}

// ============================================================================
// SURGEON-SPECIFIC FEATURES
// ============================================================================

// Doctor-to-Doctor Consultations
model DoctorConsultation {
  id                    String        @id @default(uuid())
  case_id               Int? // Optional: link to appointment/patient case
  patient_id            String? // Optional: attached patient
  requesting_doctor_id  String // Doctor who requested consultation
  consulting_doctor_id  String // Doctor being consulted
  urgency               ConsultUrgency @default(ROUTINE)
  status                ConsultStatus @default(OPEN)
  subject               String
  question              String @db.Text
  background            String? @db.Text
  what_is_needed        String? @db.Text // opinion, approval, second opinion
  response              String? @db.Text
  resolved_at           DateTime?
  resolved_by           String?
  
  // Relations
  requesting_doctor Doctor       @relation("RequestingDoctor", fields: [requesting_doctor_id], references: [id], onDelete: Cascade)
  consulting_doctor Doctor       @relation("ConsultingDoctor", fields: [consulting_doctor_id], references: [id], onDelete: Cascade)
  patient            Patient?    @relation(fields: [patient_id], references: [id], onDelete: SetNull)
  appointment        Appointment? @relation("DoctorConsultationAppointment", fields: [case_id], references: [id], onDelete: SetNull)
  attachments        ConsultationAttachment[]
  messages           ConsultationMessage[]
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([requesting_doctor_id])
  @@index([consulting_doctor_id])
  @@index([patient_id])
  @@index([case_id])
  @@index([status])
  @@index([urgency])
  @@index([created_at])
}

model ConsultationAttachment {
  id                    Int      @id @default(autoincrement())
  consultation_id       String
  file_url              String
  file_name             String
  file_type             String? // image, scan, document, etc.
  file_size             Int? // bytes
  description           String?
  
  consultation DoctorConsultation @relation(fields: [consultation_id], references: [id], onDelete: Cascade)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([consultation_id])
}

model ConsultationMessage {
  id              Int      @id @default(autoincrement())
  consultation_id String
  sender_id       String // Doctor ID
  message         String @db.Text
  is_internal     Boolean @default(true) // Internal note vs patient-facing
  
  consultation DoctorConsultation @relation(fields: [consultation_id], references: [id], onDelete: Cascade)
  sender       Doctor              @relation("ConsultationMessageSender", fields: [sender_id], references: [id], onDelete: Cascade)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([consultation_id])
  @@index([sender_id])
  @@index([created_at])
}

// Surgical Case Planning Workspace
model CasePlan {
  id                    Int      @id @default(autoincrement())
  appointment_id        Int      @unique
  patient_id            String
  doctor_id             String
  procedure_plan        String? @db.Text
  risk_factors          String? @db.Text // JSON or structured text
  pre_op_notes          String? @db.Text
  implant_details       String? @db.Text // Brand, size, model, etc.
  marking_diagram       String? // URL to diagram/image
  consent_checklist     String? @db.Text // JSON array of consent items
  planned_anesthesia    String?
  special_instructions  String? @db.Text // Instructions to theatre team
  readiness_status      CaseReadinessStatus @default(NOT_STARTED)
  ready_for_surgery     Boolean @default(false)
  
  // Relations
  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  images      PatientImage[]
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([appointment_id])
  @@index([patient_id])
  @@index([doctor_id])
  @@index([readiness_status])
}

// Before & After Image Management
model PatientImage {
  id                  Int           @id @default(autoincrement())
  patient_id          String
  appointment_id      Int?
  case_plan_id        Int?
  image_url           String
  thumbnail_url       String?
  angle               ImageAngle
  timepoint           ImageTimepoint
  custom_timepoint    String? // For CUSTOM timepoint
  description         String?
  consent_for_marketing Boolean @default(false)
  taken_by            String? // User ID
  taken_at            DateTime @default(now())
  
  // Relations
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)
  case_plan   CasePlan?   @relation(fields: [case_plan_id], references: [id], onDelete: SetNull)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([patient_id])
  @@index([appointment_id])
  @@index([timepoint])
  @@index([angle])
  @@index([taken_at])
}

// Clinical Note Templates
model ClinicalNoteTemplate {
  id                Int      @id @default(autoincrement())
  name              String
  template_type     String // CONSULTATION, PROCEDURE, POST_OP, COMPLICATION
  template_content  String @db.Text // Structured template with placeholders
  is_active         Boolean @default(true)
  created_by        String? // User ID
  used_count        Int @default(0)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([template_type])
  @@index([is_active])
}

// Task & Delegation System
model ClinicalTask {
  id              Int          @id @default(autoincrement())
  patient_id      String?
  appointment_id  Int?
  assigned_by     String // User ID who created task
  assigned_to     String // User ID who should complete task
  task_type       String // FOLLOW_UP, UPLOAD_PHOTOS, CONFIRM_LABS, etc.
  title           String
  description     String? @db.Text
  priority        TaskPriority @default(MEDIUM)
  status          TaskStatus @default(PENDING)
  due_date        DateTime?
  completed_at    DateTime?
  completion_notes String? @db.Text
  
  // Relations
  patient     Patient?     @relation(fields: [patient_id], references: [id], onDelete: SetNull)
  appointment Appointment? @relation(fields: [appointment_id], references: [id], onDelete: SetNull)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([assigned_to])
  @@index([assigned_by])
  @@index([patient_id])
  @@index([appointment_id])
  @@index([status])
  @@index([priority])
  @@index([due_date])
}

// Surgical Outcome Tracking
model SurgicalOutcome {
  id                  Int            @id @default(autoincrement())
  appointment_id      Int            @unique
  patient_id          String
  doctor_id           String
  procedure_type      String
  outcome_status      OutcomeStatus
  complication_rate   Float? // 0-1 scale
  revision_required   Boolean @default(false)
  revision_date       DateTime?
  patient_satisfaction Int? // 1-5 scale
  healing_timeline    String? @db.Text
  notes               String? @db.Text
  recorded_at         DateTime @default(now())
  recorded_by         String // User ID
  
  // Relations
  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)
  doctor      Doctor      @relation(fields: [doctor_id], references: [id], onDelete: Cascade)
  
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@index([appointment_id])
  @@index([patient_id])
  @@index([doctor_id])
  @@index([procedure_type])
  @@index([outcome_status])
  @@index([recorded_at])
}

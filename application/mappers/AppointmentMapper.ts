import { Appointment } from '../../domain/entities/Appointment';
import { ScheduleAppointmentDto } from '../dtos/ScheduleAppointmentDto';
import { AppointmentResponseDto } from '../dtos/AppointmentResponseDto';
import { AppointmentStatus } from '../../domain/enums/AppointmentStatus';
import { ConsultationRequestStatus } from '../../domain/enums/ConsultationRequestStatus';
import { ConsultationRequestFields } from '../../infrastructure/mappers/ConsultationRequestMapper';
import { DomainException } from '../../domain/exceptions/DomainException';

/**
 * Mapper: AppointmentMapper
 * 
 * Maps between Appointment DTOs and Appointment domain entities.
 * This mapper handles translation between the application layer (DTOs)
 * and the domain layer (entities).
 * 
 * Responsibilities:
 * - Convert DTOs to domain entities
 * - Convert domain entities to DTOs
 * - Handle validation and type conversion
 * - NO business logic - only data transformation
 */
export class AppointmentMapper {
  /**
   * Maps a ScheduleAppointmentDto to an Appointment domain entity
   * 
   * Note: The appointment ID will be generated by the database.
   * We use a temporary ID (0) here, which will be replaced after save.
   * 
   * @param dto - ScheduleAppointmentDto with appointment scheduling data
   * @param status - Appointment status (default: PENDING)
   * @param id - Temporary appointment ID (will be replaced after save)
   * @returns Appointment domain entity
   * @throws DomainException if validation fails
   */
  static fromScheduleDto(
    dto: ScheduleAppointmentDto,
    status: AppointmentStatus = AppointmentStatus.PENDING,
    id: number = 0,
  ): Appointment {
    return Appointment.create({
      id,
      patientId: dto.patientId,
      doctorId: dto.doctorId,
      appointmentDate: dto.appointmentDate,
      time: dto.time,
      status,
      type: dto.type,
      note: dto.note,
    });
  }

  /**
   * Maps an Appointment domain entity to an AppointmentResponseDto
   * 
   * @param appointment - Appointment domain entity
   * @param consultationRequestFields - Optional consultation request workflow fields
   * @returns AppointmentResponseDto with appointment data
   */
  static toResponseDto(
    appointment: Appointment,
    consultationRequestFields?: ConsultationRequestFields | null
  ): AppointmentResponseDto {
    const dto: AppointmentResponseDto = {
      id: appointment.getId(),
      patientId: appointment.getPatientId(),
      doctorId: appointment.getDoctorId(),
      appointmentDate: appointment.getAppointmentDate(),
      time: appointment.getTime(),
      status: appointment.getStatus(),
      type: appointment.getType(),
      note: appointment.getNote(),
      reason: appointment.getReason(),
      createdAt: appointment.getCreatedAt(),
      updatedAt: appointment.getUpdatedAt(),
    };

    // Include consultation request fields if provided
    if (consultationRequestFields) {
      dto.consultationRequestStatus = consultationRequestFields.consultationRequestStatus ?? undefined;
      dto.reviewedBy = consultationRequestFields.reviewedBy ?? undefined;
      dto.reviewedAt = consultationRequestFields.reviewedAt ?? undefined;
      dto.reviewNotes = consultationRequestFields.reviewNotes ?? undefined;
    }

    return dto;
  }

  /**
   * Creates a new Appointment entity with updated status
   * 
   * Since Appointment is immutable, we create a new instance with updated values.
   * 
   * @param existing - Existing Appointment entity
   * @param newStatus - New status to set
   * @returns New Appointment entity with updated status
   */
  static updateStatus(existing: Appointment, newStatus: AppointmentStatus): Appointment {
    return Appointment.create({
      id: existing.getId(),
      patientId: existing.getPatientId(),
      doctorId: existing.getDoctorId(),
      appointmentDate: existing.getAppointmentDate(),
      time: existing.getTime(),
      status: newStatus,
      type: existing.getType(),
      note: existing.getNote(),
      reason: existing.getReason(),
      createdAt: existing.getCreatedAt(),
      updatedAt: existing.getUpdatedAt(),
    });
  }

  /**
   * Creates a new Appointment entity with updated note
   * 
   * Since Appointment is immutable, we create a new instance with updated values.
   * 
   * @param existing - Existing Appointment entity
   * @param note - New note to set
   * @returns New Appointment entity with updated note
   */
  static updateNote(existing: Appointment, note: string): Appointment {
    return Appointment.create({
      id: existing.getId(),
      patientId: existing.getPatientId(),
      doctorId: existing.getDoctorId(),
      appointmentDate: existing.getAppointmentDate(),
      time: existing.getTime(),
      status: existing.getStatus(),
      type: existing.getType(),
      note,
      reason: existing.getReason(),
      createdAt: existing.getCreatedAt(),
      updatedAt: existing.getUpdatedAt(),
    });
  }

  /**
   * Creates a new Appointment entity with updated reason
   * 
   * Since Appointment is immutable, we create a new instance with updated values.
   * 
   * @param existing - Existing Appointment entity
   * @param reason - New reason to set
   * @returns New Appointment entity with updated reason
   */
  static updateReason(existing: Appointment, reason: string): Appointment {
    return Appointment.create({
      id: existing.getId(),
      patientId: existing.getPatientId(),
      doctorId: existing.getDoctorId(),
      appointmentDate: existing.getAppointmentDate(),
      time: existing.getTime(),
      status: existing.getStatus(),
      type: existing.getType(),
      note: existing.getNote(),
      reason,
      createdAt: existing.getCreatedAt(),
      updatedAt: existing.getUpdatedAt(),
    });
  }
}

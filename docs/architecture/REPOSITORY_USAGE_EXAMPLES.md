# Repository Usage Examples

This document provides examples of how to use the consultation infrastructure layer, including repositories, mappers, and transaction management.

## Basic Repository Usage

### ConsultationRepository

```typescript
import { PrismaClient } from '@prisma/client';
import { PrismaConsultationRepository } from '@/infrastructure/database/repositories/PrismaConsultationRepository';
import { Consultation } from '@/domain/entities/Consultation';
import { ConsultationState } from '@/domain/enums/ConsultationState';

const prisma = new PrismaClient();
const consultationRepo = new PrismaConsultationRepository(prisma);

// Find consultation by ID
const consultation = await consultationRepo.findById(1);

// Find consultation by appointment ID
const consultationByAppt = await consultationRepo.findByAppointmentId(100);

// Find consultations for a doctor with filters
const consultations = await consultationRepo.findByDoctorId('doctor-1', {
  state: ConsultationState.IN_PROGRESS,
  startDate: new Date('2025-01-01'),
  endDate: new Date('2025-01-31'),
});

// Save new consultation
const newConsultation = Consultation.create({
  id: 0, // Will be generated by DB
  appointmentId: 100,
  doctorId: 'doctor-1',
  userId: 'user-1',
});

const saved = await consultationRepo.save(newConsultation);

// Update consultation
const started = saved.start('user-1', new Date());
await consultationRepo.update(started);
```

### AppointmentRepository

```typescript
import { PrismaAppointmentRepository } from '@/infrastructure/database/repositories/PrismaAppointmentRepository';
import { AppointmentStatus } from '@/domain/enums/AppointmentStatus';

const appointmentRepo = new PrismaAppointmentRepository(prisma);

// Find potential no-shows
const now = new Date();
const potentialNoShows = await appointmentRepo.findPotentialNoShows(now, 30); // 30 minute window

// Find appointments with filters
const appointments = await appointmentRepo.findByDoctor('doctor-1', {
  status: AppointmentStatus.SCHEDULED,
  startDate: new Date('2025-01-01'),
  endDate: new Date('2025-01-31'),
});
```

## Transaction Management

### Using TransactionHelper for Aggregate Operations

When working with aggregates (e.g., Appointment + Consultation), use transactions to ensure atomicity:

```typescript
import { TransactionHelper } from '@/infrastructure/database/TransactionHelper';
import { PrismaConsultationRepository } from '@/infrastructure/database/repositories/PrismaConsultationRepository';
import { PrismaAppointmentRepository } from '@/infrastructure/database/repositories/PrismaAppointmentRepository';

const consultationRepo = new PrismaConsultationRepository(prisma);
const appointmentRepo = new PrismaAppointmentRepository(prisma);

// Example: Start consultation (updates both appointment and creates consultation)
await TransactionHelper.execute(prisma, async (tx) => {
  // Create transaction-scoped repositories
  const txConsultationRepo = new PrismaConsultationRepository(tx);
  const txAppointmentRepo = new PrismaAppointmentRepository(tx);

  // Update appointment status
  const appointment = await txAppointmentRepo.findById(appointmentId);
  if (!appointment) {
    throw new Error('Appointment not found');
  }

  // Create and save consultation
  const consultation = Consultation.create({
    id: 0,
    appointmentId: appointment.getId(),
    doctorId: appointment.getDoctorId(),
    userId: currentUserId,
  }).start(currentUserId, new Date());

  await txConsultationRepo.save(consultation);
});
```

### Multiple Operations in Transaction

```typescript
await TransactionHelper.executeAll(prisma, [
  async (tx) => {
    const repo = new PrismaConsultationRepository(tx);
    await repo.update(consultation);
  },
  async (tx) => {
    const repo = new PrismaAppointmentRepository(tx);
    await repo.update(appointment);
  },
]);
```

## Event Publishing

### Using EventPublisher

```typescript
import { EventPublisher } from '@/infrastructure/services/EventPublisher';
import { AppointmentCheckedInEvent } from '@/domain/events/ConsultationEvents';

const eventPublisher = new EventPublisher();

// Register event handlers
eventPublisher.on('AppointmentCheckedIn', async (event) => {
  console.log('Appointment checked in:', event);
  // Send notification, update audit log, etc.
});

// Publish event
const event: AppointmentCheckedInEvent = {
  eventId: `appointment-checked-in-${appointmentId}-${Date.now()}`,
  occurredAt: new Date(),
  aggregateId: appointmentId,
  eventType: 'AppointmentCheckedIn',
  appointmentId,
  patientId,
  doctorId,
  checkedInAt: new Date(),
  checkedInBy: userId,
  isLateArrival: false,
  lateByMinutes: undefined,
};

await eventPublisher.publish(event);
```

## Complete Example: Starting a Consultation

```typescript
import { PrismaClient } from '@prisma/client';
import { TransactionHelper } from '@/infrastructure/database/TransactionHelper';
import { PrismaConsultationRepository } from '@/infrastructure/database/repositories/PrismaConsultationRepository';
import { PrismaAppointmentRepository } from '@/infrastructure/database/repositories/PrismaAppointmentRepository';
import { EventPublisher } from '@/infrastructure/services/EventPublisher';
import { Consultation } from '@/domain/entities/Consultation';
import { ConsultationStartedEvent } from '@/domain/events/ConsultationEvents';

async function startConsultation(
  appointmentId: number,
  userId: string,
  prisma: PrismaClient,
  eventPublisher: EventPublisher
): Promise<Consultation> {
  return TransactionHelper.execute(prisma, async (tx) => {
    const consultationRepo = new PrismaConsultationRepository(tx);
    const appointmentRepo = new PrismaAppointmentRepository(tx);

    // Load appointment
    const appointment = await appointmentRepo.findById(appointmentId);
    if (!appointment) {
      throw new Error('Appointment not found');
    }

    // Check if consultation already exists
    let consultation = await consultationRepo.findByAppointmentId(appointmentId);

    if (!consultation) {
      // Create new consultation
      consultation = Consultation.create({
        id: 0,
        appointmentId: appointment.getId(),
        doctorId: appointment.getDoctorId(),
        userId,
      });
    }

    // Start consultation
    const started = consultation.start(userId, new Date());

    // Save consultation
    const saved = await consultationRepo.save(started);

    // Publish event (outside transaction for better performance)
    const event: ConsultationStartedEvent = {
      eventId: `consultation-started-${saved.getId()}-${Date.now()}`,
      occurredAt: new Date(),
      aggregateId: saved.getId(),
      eventType: 'ConsultationStarted',
      consultationId: saved.getId(),
      appointmentId: saved.getAppointmentId(),
      doctorId: saved.getDoctorId(),
      startedAt: saved.getStartedAt()!,
    };

    // Publish after transaction commits
    await eventPublisher.publish(event);

    return saved;
  });
}
```

## Best Practices

1. **Always use transactions for aggregate operations** - When updating multiple related entities, use `TransactionHelper` to ensure atomicity.

2. **Repository methods return domain entities** - Never expose Prisma models outside the infrastructure layer.

3. **Handle Prisma errors gracefully** - Repositories wrap Prisma errors in domain-friendly error messages.

4. **Use mappers for conversion** - Never manually convert between Prisma and domain models. Always use mappers.

5. **Publish events after transactions** - Publish domain events after the transaction commits to avoid publishing events for failed operations.

6. **Use transaction-scoped repositories** - When using transactions, create new repository instances with the transaction client.

## Error Handling

```typescript
try {
  const consultation = await consultationRepo.findById(1);
  if (!consultation) {
    // Handle not found
    return;
  }

  const updated = consultation.updateNotes(notes);
  await consultationRepo.update(updated);
} catch (error) {
  if (error instanceof Error) {
    if (error.message.includes('not found')) {
      // Handle not found error
    } else if (error.message.includes('constraint')) {
      // Handle constraint violation
    } else {
      // Handle other errors
    }
  }
}
```

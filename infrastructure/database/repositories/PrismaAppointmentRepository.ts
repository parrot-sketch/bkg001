import { IAppointmentRepository } from '../../../domain/interfaces/repositories/IAppointmentRepository';
import { Appointment } from '../../../domain/entities/Appointment';
import { AppointmentMapper } from '../../mappers/AppointmentMapper';
import { ConsultationRequestFields, toPrismaCreateConsultationRequestFields, toPrismaConsultationRequestFields, extractConsultationRequestFields } from '../../mappers/ConsultationRequestMapper';
import { PrismaClient, Prisma } from '@prisma/client';

/**
 * Repository: PrismaAppointmentRepository
 * 
 * Prisma-based implementation of IAppointmentRepository.
 * This repository handles data persistence for Appointment entities using Prisma ORM.
 * 
 * Responsibilities:
 * - Translate domain operations to Prisma operations
 * - Map between Prisma models and domain entities
 * - Handle database-specific concerns (transactions, errors)
 * - NO business logic - only data access
 * 
 * Clean Architecture Rule: This class depends on domain interfaces and entities,
 * not the other way around. Domain knows nothing about Prisma.
 */
export class PrismaAppointmentRepository implements IAppointmentRepository {
  constructor(private readonly prisma: PrismaClient) {
    if (!prisma) {
      throw new Error('PrismaClient is required');
    }
  }

  /**
   * Finds an appointment by its unique identifier
   * 
   * @param id - The appointment's unique identifier (numeric ID)
   * @returns Promise resolving to the Appointment entity if found, null otherwise
   */
  async findById(id: number): Promise<Appointment | null> {
    try {
      const prismaAppointment = await this.prisma.appointment.findUnique({
        where: { id },
      });

      if (!prismaAppointment) {
        return null;
      }

      return AppointmentMapper.fromPrisma(prismaAppointment);
    } catch (error) {
      // Wrap Prisma errors in a more generic error
      throw new Error(`Failed to find appointment by ID: ${id}. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Finds all appointments for a specific patient
   * 
   * @param patientId - The patient's unique identifier
   * @returns Promise resolving to an array of Appointment entities
   *          Returns empty array if no appointments found
   */
  async findByPatient(patientId: string): Promise<Appointment[]> {
    try {
      const prismaAppointments = await this.prisma.appointment.findMany({
        where: { patient_id: patientId },
        orderBy: { appointment_date: 'desc' },
      });

      return prismaAppointments.map((appointment) => AppointmentMapper.fromPrisma(appointment));
    } catch (error) {
      // Wrap Prisma errors in a more generic error
      throw new Error(`Failed to find appointments for patient: ${patientId}. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Finds all appointments for a specific doctor
   * 
   * @param doctorId - The doctor's unique identifier
   * @returns Promise resolving to an array of Appointment entities
   *          Returns empty array if no appointments found
   */
  async findByDoctor(doctorId: string): Promise<Appointment[]> {
    try {
      const prismaAppointments = await this.prisma.appointment.findMany({
        where: { doctor_id: doctorId },
        orderBy: { appointment_date: 'desc' },
      });

      return prismaAppointments.map((appointment) => AppointmentMapper.fromPrisma(appointment));
    } catch (error) {
      // Wrap Prisma errors in a more generic error
      throw new Error(`Failed to find appointments for doctor: ${doctorId}. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Saves a new appointment to the data store
   * 
   * This method handles creation of new appointments.
   * The appointment ID will be generated by the database.
   * 
   * @param appointment - The Appointment entity to save
   * @param consultationRequestFields - Optional consultation request workflow fields
   * @returns Promise that resolves when the save operation completes
   * @throws Error if the save operation fails
   */
  async save(appointment: Appointment, consultationRequestFields?: ConsultationRequestFields): Promise<void> {
    try {
      const createInput = AppointmentMapper.toPrismaCreateInput(appointment);
      
      // Merge consultation request fields if provided
      if (consultationRequestFields) {
        const consultationFields = toPrismaCreateConsultationRequestFields(consultationRequestFields);
        Object.assign(createInput, consultationFields);
      }

      await this.prisma.appointment.create({
        data: createInput,
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          // Unique constraint violation
          throw new Error(`Appointment with ID ${appointment.getId()} already exists`);
        }
        if (error.code === 'P2003') {
          // Foreign key constraint violation
          throw new Error(`Invalid patient or doctor ID for appointment`);
        }
      }
      // Wrap Prisma errors in a more generic error
      throw new Error(`Failed to save appointment. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Updates an existing appointment in the data store
   * 
   * The appointment must already exist in the data store.
   * 
   * @param appointment - The Appointment entity with updated information
   * @param consultationRequestFields - Optional consultation request workflow fields
   * @returns Promise that resolves when the update operation completes
   * @throws Error if the appointment does not exist or the update fails
   */
  async update(appointment: Appointment, consultationRequestFields?: ConsultationRequestFields): Promise<void> {
    try {
      const updateInput = AppointmentMapper.toPrismaUpdateInput(appointment);
      
      // Merge consultation request fields if provided
      if (consultationRequestFields) {
        const consultationFields = toPrismaConsultationRequestFields(consultationRequestFields);
        Object.assign(updateInput, consultationFields);
      }

      await this.prisma.appointment.update({
        where: { id: appointment.getId() },
        data: updateInput,
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
          // Record not found
          throw new Error(`Appointment with ID ${appointment.getId()} not found`);
        }
      }
      // Wrap Prisma errors in a more generic error
      throw new Error(`Failed to update appointment: ${appointment.getId()}. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Gets consultation request fields for an appointment
   * 
   * @param appointmentId - The appointment ID
   * @returns Promise resolving to consultation request fields or null if not found
   */
  async getConsultationRequestFields(appointmentId: number): Promise<ConsultationRequestFields | null> {
    try {
      const prismaAppointment = await this.prisma.appointment.findUnique({
        where: { id: appointmentId },
        select: {
          consultation_request_status: true,
          reviewed_by: true,
          reviewed_at: true,
          review_notes: true,
        },
      });

      if (!prismaAppointment) {
        return null;
      }

      return extractConsultationRequestFields(prismaAppointment);
    } catch (error) {
      throw new Error(`Failed to get consultation request fields for appointment ${appointmentId}. ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}
